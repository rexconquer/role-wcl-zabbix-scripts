#
# {{ ansible_managed }}
#
# This script get redis status by querying with INFO command
# through socket
#
# author: Song



import socket
import sys


BUFFER_SIZE = 512
REDIS_HOST = "{{ zabbix_redis.host }}"
REDIS_PORT = "{{ zabbix_redis.port }}"
REDIS_PASSWORD = "{{ zabbix_redis.password }}"


# Sample redis info formatted as dictionary
# Pass one of the keys below as argument when
# running this script

# Example: python redis.py tcp_port

# {
# 'aof_current_rewrite_time_sec': '-1',
# 'aof_enabled': '0',
# 'aof_last_bgrewrite_status': 'ok',
# 'aof_last_rewrite_time_sec': '-1',
# 'aof_last_write_status': 'ok',
# 'aof_rewrite_in_progress': '0',
# 'aof_rewrite_scheduled': '0',
# 'arch_bits': '64',
# 'blocked_clients': '0',
# 'client_biggest_input_buf': '0',
# 'client_longest_output_list': '0',
# 'cluster_enabled': '0',
# 'cmdstat_info': 'calls=9,usec=643,usec_per_call=71.44',
# 'config_file': '/etc/redis/6379.conf',
# 'connected_clients': '1',
# 'connected_slaves': '0',
# 'evicted_keys': '0',
# 'expired_keys': '0',
# 'gcc_version': '4.8.4',
# 'hz': '10',
# 'instantaneous_input_kbps': '0.00',
# 'instantaneous_ops_per_sec': '0',
# 'instantaneous_output_kbps': '0.00',
# 'keyspace_hits': '0',
# 'keyspace_misses': '0',
# 'latest_fork_usec': '0',
# 'loading': '0',
# 'lru_clock': '7925590',
# 'master_repl_offset': '0',
# 'mem_allocator': 'jemalloc-3.6.0',
# 'mem_fragmentation_ratio': '9.30',
# 'migrate_cached_sockets': '0',
# 'multiplexing_api': 'epoll',
# 'os': 'Linux 3.13.0-67-generic x86_64',
# 'process_id': '2637',
# 'pubsub_channels': '0',
# 'pubsub_patterns': '0',
# 'rdb_bgsave_in_progress': '0',
# 'rdb_changes_since_last_save': '0',
# 'rdb_current_bgsave_time_sec': '-1',
# 'rdb_last_bgsave_status': 'ok',
# 'rdb_last_bgsave_time_sec': '-1',
# 'rdb_last_save_time': '1450758428',
# 'redis_build_id': '50ff14e64ac158eb',
# 'redis_git_dirty': '0',
# 'redis_git_sha1': '00000000',
# 'redis_mode': 'standalone',
# 'redis_version': '3.0.5',
# 'rejected_connections': '0',
# 'repl_backlog_active': '0',
# 'repl_backlog_first_byte_offset': '0',
# 'repl_backlog_histlen': '0',
# 'repl_backlog_size': '1048576',
# 'role': 'master',
# 'run_id': '2f13a210566937a3ff3af71bef74c3b2f7cfbaf7',
# 'sync_full': '0',
# 'sync_partial_err': '0',
# 'sync_partial_ok': '0',
# 'tcp_port': '6379',
# 'total_commands_processed': '9',
# 'total_connections_received': '10',
# 'total_net_input_bytes': '100',
# 'total_net_output_bytes': '17794',
# 'uptime_in_days': '0',
# 'uptime_in_seconds': '7738',
# 'used_cpu_sys': '10.18',
# 'used_cpu_sys_children': '0.00',
# 'used_cpu_user': '6.03',
# 'used_cpu_user_children': '0.00',
# 'used_memory': '816008',
# 'used_memory_human': '796.88K',
# 'used_memory_lua': '36864',
# 'used_memory_peak': '816008',
# 'used_memory_peak_human': '796.88K',
# 'used_memory_rss': '7589888'}


class RedisError(Exception):
    pass

# The response of INFO command is formatted as "RESP Bulk Strings"

# Read redis protocol specification about "RESP Bulk Strings"
# http://redis.io/topics/protocol

# For example, the returned string from redis "foobar" is encoded as like this:
# "$6\r\nfoobar\r\n", 6 is the length of the content.
# This function first tries to find the length, then read the content.

def read_redis_info(host, port):
    """ Get redis status info by sending 'INFO ALL' to socket. """
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))

    # Validate redis password
    # First, sending AUTH password
    # then, tries to get first three characters responeded from redis
    # if it is "+OK", then read the trailing \r\n
    # if not, read the rest of the message, and raise that message as error.

    if REDIS_PASSWORD:
        s.sendall("AUTH %s\r\n" % REDIS_PASSWORD)
        msg = s.recv(3)
        if msg == "+OK":
            s.recv(2)  # Read \r\n
        else:
            error_msg = msg
            while True:
                character = s.recv(1)
                if character == "\r" and s.recv(1) == "\n":
                    break
                else:
                    error_msg += character
            s.close()
            raise RedisError(error_msg)

    s.sendall("INFO ALL\r\n" )
    content = ""
    msg = ""
    while True:
        data = s.recv(1)
        msg += data
        if data == "\r" and s.recv(1) == "\n":
            if msg[0] == "-":  # if "-" is the first char we receive, then the msg is error
                s.close()
                raise RedisError(msg)
            length = int(msg[1:-1]) + 2  # including /r/n
            break

    while True:
        data = s.recv(BUFFER_SIZE)
        length -= len(data)
        content += data
        if length <= 0:
            break

    s.close()
    return content


def parse_redis_info(content):
    """ Parse the redis info we get. """
    parsed_content = dict()
    lines = content.split("\r\n")
    for line in lines:
        if line == "" or line.startswith("#"):
            continue

        key, value = line.split(":", 1)
        parsed_content[key] = value

    return parsed_content


if __name__ == '__main__':

    if len(sys.argv) != 2:
        print "argument not provided."
        exit(1)
    else:
        arg = sys.argv[1]

        try:
            content = read_redis_info(REDIS_HOST, int(REDIS_PORT))
        except socket.error as e:
            print "Socket Error: %s" % e
            exit(1)
        except RedisError as e:
            print "Redis Error: %s" % e
            exit(1)
        except Exception as e:
            print "Unexpected Error: %s" % e
            exit(1)

        result = parse_redis_info(content)

        if not result:
            print "Cannot find any key / value pair from redis INFO command."
            exit(1)

        if arg in result.keys():
            print(result[arg])
        else:
            print("Key (%s) cannot be found." % arg)
            exit(1)
